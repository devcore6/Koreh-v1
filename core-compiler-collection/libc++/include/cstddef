/*
 * The Koreh-v1 Project
 * Koreh-v1 C++ Compiler (ccxx)
 * 
 * Copyright (C) 2021, Bryan "/dev/core" M.
 * Licensed under the Mozilla Public License 2.0
 * https://www.mozilla.org/en-US/MPL/2.0/
 * 
 * Common language definitions as defined in
 * Clause 17.2 of the ISO-C++ 23 working draft.
 * 
 * Matching source files: language-support/cstddef.cpp
 *
 * The ISO documents referenced by this compiler can be found at
 * http://open-std.org/JTC1/SC22/WG21/docs/papers/2020/n4878.pdf
 *
 */

/*
 * synopsys:
 * 
 * extern "C++" {
 * 
 * __BEGIN_NAMESPACE_STD
 * #if __ARCH == 64
 * using ptrdiff_t = long long;
 * using size_t = unsigned long long;
 * #else
 * using ptrdiff_t = long;
 * using size_t = unsigned long;
 * #endif
 * using max_align_t = long double;
 * using nullptr_t = decltype(nullptr);
 * enum class byte : unsigned char {};
 * template<class IntType>
 * constexpr byte& operator<<=(byte& b, IntType shift) noexcept;
 * template<class IntType>
 * constexpr byte operator<<(byte b, IntType shift) noexcept;
 * template<class IntType>
 * constexpr byte& operator>>=(byte& b, IntType shift) noexcept;
 * template<class IntType>
 * constexpr byte operator>>(byte b, IntType shift) noexcept;
 * constexpr byte& operator|=(byte& l, byte r) noexcept;
 * constexpr byte operator|(byte l, byte r) noexcept;
 * constexpr byte& operator&=(byte& l, byte r) noexcept;
 * constexpr byte operator&(byte l, byte r) noexcept;
 * constexpr byte& operator^=(byte& l, byte r) noexcept;
 * constexpr byte operator^(byte l, byte r) noexcept;
 * constexpr byte operator~(byte b) noexcept;
 * template<class IntType>
 * constexpr IntType to_integer(byte b) noexcept;
 * __END_NAMESPACE_STD
 * 
 * #define NULL
 * #define offsetof(P, D)
 * 
 * }
 * 
 */

#ifndef __LIBCPP__CSTDDEF
# define __LIBCPP__CSTDDEF

# include <config>

extern "C++" {

	__BEGIN_NAMESPACE_STD

# if __ARCH == 64
		using ptrdiff_t = long long;
		using size_t = unsigned long long;
# else
		using ptrdiff_t = long;
		using size_t = unsigned long;
 #endif // __ARCH == 64
		using max_align_t = long double;
		using nullptr_t = decltype(nullptr);
		enum class byte : unsigned char {};
		template<class IntType>
		constexpr byte& operator<<=(byte& b, IntType shift) noexcept;
		template<class IntType>
		constexpr byte operator<<(byte b, IntType shift) noexcept;
		template<class IntType>
		constexpr byte& operator>>=(byte& b, IntType shift) noexcept;
		template<class IntType>
		constexpr byte operator>>(byte b, IntType shift) noexcept;
		constexpr byte& operator|=(byte& l, byte r) noexcept;
		constexpr byte operator|(byte l, byte r) noexcept;
		constexpr byte& operator&=(byte& l, byte r) noexcept;
		constexpr byte operator&(byte l, byte r) noexcept;
		constexpr byte& operator^=(byte& l, byte r) noexcept;
		constexpr byte operator^(byte l, byte r) noexcept;
		constexpr byte operator~(byte b) noexcept;
		template<class IntType>
		constexpr IntType to_integer(byte b) noexcept;

	__END_NAMESPACE_STD

	/*
	 * Clause 17.2.3 paragraph 2 defines NULL as a macro to a
	 * null pointer constant
	 */
# ifndef NULL
#  define NULL nullptr
# endif

	/*
	 * We define offsetoff through a builtin language extension in the compiler
	 */
# define offsetof(P, D) \
		__builtin_offsetof(P, D)

} // extern "C++"

#endif // __LIBCPP__CSTDDEF
